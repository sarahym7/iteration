---
title: "lis_col"
author: "Sarahy Martinez"
date: "2024-10-29"
output: github_document
---

```{r}
library(tidyverse)
library(rvest)

knitr::opts_chunk$set(
  fig.width = 6,
  fig.asp = .6,
  out.width = "90%:"
  
)


theme_set(theme_minimal()+ theme(legend.position = "bottom"))


options(
  ggplot2.continuous.colour = "viridis",
  ggplot2.continuous.fill = "viridis"
)
```


## Lists 

You can put anything in a list 

```{r}


l = list (
 # no way we can put all of this information into a dataframe so we will make a list
vec_numeric = 5:8,
vec_logical = c(TRUE, TRUE , FALSE, TRUE, FALSE, FALSE),
mat = matrix(1:8, nrow = 2, ncol= 4),
summary = summary(rnorm(100)) 
  
)


```



```{r}
l  # now we have a way of storing everyhting instead of different datafra,s 


l$vec_numeric #will give you data of just vec_numeric

l[[1]] # returns first list

l[["vec_numeric"]]  #also returns first list 

mean(l[["vec_numeric"]]) # if accessing individual elements of the list

```



## `for` loop 

Create a new list. 


```{r}

list_norm = 
    list(
      a = rnorm(20, mean = 3, sd= 1),
      b = rnorm(30, mean = 0, sd= 5),
      c = rnorm(40, mean = 10, sd= .2),
      d = rnorm(20, mean = -3, sd= 1)
    )

#basis is that this is something that we cannot easily do individually 

```


```{r}

list_norm[[1]] # first element of your list 
```



pause anf get old function 

- write a function that give the mean and standard deviation

```{r}


mean_and_sd = function(x) {
  if (!is.numeric(x)) {
    stop("Argument x should be numeric")
  } 
  
  if (length(x) <3) {
  stop("Input must have at least 3 numbers")
  }
  
  mean_x = mean(x)
  sd_x = sd(x)

  tibble(
    mean = mean_x, 
    sd = sd_x
  )
}


```

I can apply this function to each list element 

```{r}

mean_and_sd(list_norm[[1]]) # don't forget to load libraries! , can get mean and std deviation of the lists
mean_and_sd(list_norm[[2]])
mean_and_sd(list_norm[[3]])
mean_and_sd(list_norm[[4]])

# even though we have a function we have to copy them 1-4 times, can be annoying if  we had 4 so we will go into for list loop


```

Let's use a for a loop 

```{r}

output = vector("list", length = 4)

for( i in 1:4){

output[[i]] = mean_and_sd(list_norm[[i]]) # possible but we're gonna have to do this 40 times and that's no fun

}


# keep track of your i and see where you have to change and replace 


```




## Let's try map! 

if we can take map as a function and give input list with function we want to apply hopefull it will do the same process

```{r}

map(list_norm, mean_and_sd)   #gives you output same as the loop

output = map(list_norm, mean_and_sd) # these two code chunks will be equivalent with the difference that map keeps track of input names

```


what if you want a different function?

```{r}

output = map(list_norm, median) # gives you the median instead of mean and sd 

output = map(list_norm, IQR)  # you can map any functions you want across the input list, can apply functions to any element of your input list and the map statement should be clear

```


we know when we run input we get A,B,D,D and its a list. So what if its a dbl?

```{r}

output = map_dbl(list_norm, median)


output = map_dbl(list_norm, median, .id = "input")

```




```{r}

output = map_df(list_norm, mean_and_sd, .id = "input")  # we cant call it dbl bc they're not individual numbers, lets try to make it a df
                                            # will take each df and collapse, keeping track of id a, b,c,d ( list names) will be helpful. tells put the list names into an input column.

```



We've got for loops, map statements, lists, we are keeping track of everything. we dont want all of this stuff where output came from this list etc. So we are going into list columns.


Create a df that has a list in it. 



## List Columns! 

```{r}

listcol_df = 
  tibble(
    name = c("a", "b", "c", "d"),
    samp = list_norm
  )

# sure theres a lot of stuff but the printed table is making easier by saying you have a list in this column with a collection of dbls 

```




```{r}
listcol_df %>%  pull(name)
listcol_df %>%  pull(samp)

# its a df and we can sample 


listcol_df %>%  filter(name == "a")

```



Lets try some operations

```{r}

listcol_df$samp  # dollar is same as pulling and gives you a list 

listcol_df$samp[[1]] 


# we want mean and sd 


mean_and_sd(listcol_df$samp[[1]])



```


What if we want to apply it all the way through. Can't we just map?




